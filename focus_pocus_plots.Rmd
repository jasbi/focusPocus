---
title: "Template Plots"
author: "Masoud Jasbi"
date: "`r Sys.Date()`"
output: pdf_document
---
#Load the necessary packages

```{r packages, include=FALSE} 
library(tidyverse)   # Includes ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats
library(stringr)     # For str_extract_all
library(readr)       # For read_csv and write_csv
library(dplyr)       # For data manipulation (filter, mutate, group_by, summarize, etc.)
library(tidyr)       # For separate
library(ggplot2)
library(brms)# For plotting with ggplot

```

# Load Tidy Data that was created at the end of data wrangling, and change the numeric values in the response column to readable values. 

``` {r}


# Read the CSV file
english_tidy_data <- read.csv("english_tidydata.csv", stringsAsFactors = FALSE)
hungarian_tidy_data <- read.csv("hungarian_tidydata.csv", stringsAsFactors = FALSE)
hungarian2_tidy_data <- read.csv("hungarian2_tidydata.csv", stringsAsFactors = FALSE)

# Define mapping of numbers to text
# This is the order of the cards in Qualtrics. The species of the animals varies (cat, dog, bird, elephant), but the order of the card is always the same: the first card has the first animal, the second card has the second animal, the third card has no animals, and the fourth card has both animals from the first and second cards. 

mapping <- c("1" = "animal 1", "2" = "animal 2", "3" = "no animal", "4" = "both animals")

# Function to replace numbers with text
replace_numbers <- function(x) {
  numbers <- unlist(str_extract_all(as.character(x), "\\d+"))  # Extract all numbers
  if (length(numbers) > 0) {
    return(paste(mapping[numbers], collapse = ", "))  # Replace and join with ", "
  } else {
    return(x)  # Return unchanged if no numbers found
  }
}

# Apply the function to the response column in the tidy_data
english_tidy_data$response <- sapply(english_tidy_data$response, replace_numbers)
hungarian_tidy_data$response <- sapply(hungarian_tidy_data$response, replace_numbers)
hungarian2_tidy_data$response <- sapply(hungarian2_tidy_data$response, replace_numbers)

# Save the modified data into a csv. 
write.csv(english_tidy_data, "english_tidydata_modified.csv", row.names = FALSE)
write.csv(hungarian_tidy_data, "hungarian_tidydata_modified.csv", row.names = FALSE)
write.csv(hungarian2_tidy_data, "hungarian2_tidydata_modified.csv", row.names = FALSE)
```

#Plotting the data

```{r}
#extracting the data without the "control" suffix
#Load experimental data from the modified tidy data. 
english_modified_tidy_data <- read.csv("english_tidydata_modified.csv")
hungarian_modified_tidy_data <- read.csv("hungarian_tidydata_modified.csv")
hungarian2_modified_tidy_data <- read.csv("hungarian2_tidydata_modified.csv")

english_experimental_data <- english_modified_tidy_data %>%
    filter(!grepl("^Control", question))
hungarian_experimental_data <- hungarian_modified_tidy_data %>%
    filter(!grepl("^Control", question))
hungarian2_experimental_data <- hungarian2_modified_tidy_data %>%
    filter(!grepl("^Control", question))

#new


#separata the question names from their stress number. 
#name example: not_and_eb_001, not_and_eb_101. The function below separates the name not_and_eb from the number. 
#the number at the end of the name is the stress number. If the first number is zero (001), then "not"is stressed. 
#if the first number is 1 (101), then the coordinating conjunction is stressed. 

english_experimental_data <- english_experimental_data %>%
  separate(question, into = c("not", "conjunction", "animals", "stress_number"), 
           sep = "_", fill = "right")
english_experimental_data <- english_experimental_data %>%
  mutate(not_conjunction = paste(not, conjunction, sep = "_"))
english_experimental_data <- english_experimental_data %>%
  select(-not, -conjunction)

hungarian_experimental_data <- hungarian_experimental_data %>%
  separate(question, into = c("not", "conjunction", "animals", "stress_number"), 
           sep = "_", fill = "right")
hungarian_experimental_data <- hungarian_experimental_data %>%
  mutate(not_conjunction = paste(not, conjunction, sep = "_"))
hungarian_experimental_data <- hungarian_experimental_data %>%
  select(-not, -conjunction)

hungarian2_experimental_data <- hungarian2_experimental_data %>%
  separate(question, into = c("not", "conjunction", "animals", "stress_number"), 
           sep = "_", fill = "right")
hungarian2_experimental_data <- hungarian2_experimental_data %>%
  mutate(not_conjunction = paste(not, conjunction, sep = "_"))
hungarian2_experimental_data <- hungarian2_experimental_data %>%
  select(-not, -conjunction)


#create question groups by the stress number. 

english_experimental_data <- english_experimental_data %>%
  mutate(group_combined = case_when(
    not_conjunction == "not_or" & stress_number %in% c("001", "002", "003") ~ "NOT_or",
    not_conjunction == "not_or" & stress_number %in% c(101, 102, 103) ~ "not_OR",
    not_conjunction == "not_and" & stress_number %in% c("001", "002", "003") ~ "NOT_and",
    not_conjunction == "not_and" & stress_number %in% c(101, 102, 103) ~ "not_AND",
    TRUE ~ not_conjunction 
  ))
hungarian_experimental_data <- hungarian_experimental_data %>%
  mutate(group_combined = case_when(
    not_conjunction == "not_or" & stress_number %in% c("001", "002", "003") ~ "NOT_or",
    not_conjunction == "not_or" & stress_number %in% c(101, 102, 103) ~ "not_OR",
    not_conjunction == "not_and" & stress_number %in% c("001", "002", "003") ~ "NOT_and",
    not_conjunction == "not_and" & stress_number %in% c(101, 102, 103) ~ "not_AND",
    TRUE ~ not_conjunction 
  ))
hungarian2_experimental_data <- hungarian2_experimental_data %>%
  mutate(group_combined = case_when(
    not_conjunction == "not_or" & stress_number %in% c("001", "002", "003") ~ "NOT_or",
    not_conjunction == "not_or" & stress_number %in% c(101, 102, 103) ~ "not_OR",
    not_conjunction == "not_and" & stress_number %in% c("001", "002", "003") ~ "NOT_and",
    not_conjunction == "not_and" & stress_number %in% c(101, 102, 103) ~ "not_AND",
    TRUE ~ not_conjunction 
  ))

write_csv(english_experimental_data, "english_experimental_data.csv")
write_csv(hungarian_experimental_data, "hungarian_experimental_data.csv")
write_csv(hungarian2_experimental_data, "hungarian2_experimental_data.csv")

# Calculate proportions
english_data_summary <- english_experimental_data %>%
  group_by(group_combined, response) %>%
  summarize(count = n()) %>%
  mutate(proportion = count / sum(count))
hungarian_data_summary <- hungarian_experimental_data %>%
  group_by(group_combined, response) %>%
  summarize(count = n()) %>%
  mutate(proportion = count / sum(count))
hungarian2_data_summary <- hungarian2_experimental_data %>%
  group_by(group_combined, response) %>%
  summarize(count = n()) %>%
  mutate(proportion = count / sum(count))

#write the data summary into a csv

write_csv(english_data_summary, "english_data_summary.csv")
write_csv(hungarian_data_summary, "hungarian_data_summary.csv")
write_csv(hungarian2_data_summary, "hungarian2_data_summary.csv")

# define custom colors
custom_colors <- c(
  "animal 1, animal 2" = "#808080",        # Medium gray
  "animal 1, animal 2, no animal" = "#FFD200",  # UC Davis gold
  "animal 1, no animal" = "#94BFA2",       # Cool green
  "animal 2" = "#2F4858",                  # Deep slate
  "animal 2, no animal" = "#A5C8E1",       # Soft blue
  "both animals" = "#F1F1F1",              # Pale gray
  "no animal" = "#002855",                # UC Davis blue
  "NA" = "#D0D0D0"                         # Light gray
)

# Create the stacked bar plot
ggplot(english_data_summary, aes(x = group_combined, 
                         y = proportion, 
                         fill = as.factor(response))) + 
  geom_bar(stat = "identity") +
  scale_fill_manual(values = custom_colors) +
  labs(x = "Question Group", 
       y = "Proportion of Responses", 
       fill = "Response") +
  theme_bw(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )
ggplot(hungarian_data_summary, aes(x = group_combined, 
                         y = proportion, 
                         fill = as.factor(response))) + 
  geom_bar(stat = "identity") +
  scale_fill_manual(values = custom_colors) +
  labs(x = "Question Group", 
       y = "Proportion of Responses", 
       fill = "Response") +
  theme_bw(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )
ggplot(hungarian2_data_summary, aes(x = group_combined, 
                         y = proportion, 
                         fill = as.factor(response))) + 
  geom_bar(stat = "identity") +
  scale_fill_manual(values = custom_colors) +
  labs(x = "Question Group", 
       y = "Proportion of Responses", 
       fill = "Response") +
  theme_bw(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )


# Create the stacked bar plot
ggplot(english_data_summary, aes(x = group_combined, 
                        y = proportion, 
                        fill = as.factor(response))) + 
  geom_bar(stat = "identity") +
  labs(x = "Question Group", 
       y = "Proportion of Responses", 
       fill = "Response") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(hungarian_data_summary, aes(x = group_combined, 
                        y = proportion, 
                        fill = as.factor(response))) + 
  geom_bar(stat = "identity") +
  labs(x = "Question Group", 
       y = "Proportion of Responses", 
       fill = "Response") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(hungarian2_data_summary, aes(x = group_combined, 
                        y = proportion, 
                        fill = as.factor(response))) + 
  geom_bar(stat = "identity") +
  labs(x = "Question Group", 
       y = "Proportion of Responses", 
       fill = "Response") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```
```{r}
library(ggplot2)
library(dplyr)

# Define a consistent theme for all plots
pretty_theme <- theme_minimal(base_size = 16) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 14),
    axis.text.y = element_text(size = 14),
    axis.title = element_text(size = 16, face = "bold"),
    legend.position = "right",
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 13),
    panel.grid.major = element_line(color = "gray85"),
    panel.grid.minor = element_blank(),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5)
  )

# Define your refined color palette
custom_colors <- c(
  "animal 1, animal 2" = "#F6A623",       # golden poppy orange
  "animal 1, animal 2, no animal" = "#FFD76D",  # light golden yellow
  "animal 1, no animal" = "#D78E04",      # deep orange
  "animal 2" = "#A65628",                # burnt sienna / earthy red
  "animal 2, no animal" = "#D9A86C",     # desert sand
  "both animals" = "#FBEEC1",            # poppy petal cream
  "no animal" = "#6B8E23",               # olive green
  "NA" = "#CFCFC4"                       # warm neutral
)

# Define a function to make the plots pretty and reusable
make_pretty_plot <- function(data, title) {
  ggplot(data, aes(x = group_combined, y = proportion, fill = as.factor(response))) +
    geom_bar(stat = "identity", width = 0.7) +
    scale_fill_manual(values = custom_colors) +
    labs(
      x = "Stress Condition",
      y = "Proportion of Responses",
      fill = "Response Type",
      title = title
    ) +
    pretty_theme
}

# Now generate all three
english_plot <- make_pretty_plot(english_data_summary, "English")
hungarian_plot <- make_pretty_plot(hungarian_data_summary, "Hungarian 1")
hungarian2_plot <- make_pretty_plot(hungarian2_data_summary, "Hungarian 2")

# Print them (you can also use patchwork or gridExtra to combine if needed)
print(english_plot)
print(hungarian_plot)
print(hungarian2_plot)

```

```{r}
library(tidyverse)

# --------------------------------------------------
# 1. Load data
# --------------------------------------------------
english_modified_tidy_data <- read.csv("english_tidydata_modified.csv")
hungarian_modified_tidy_data <- read.csv("hungarian_tidydata_modified.csv")
hungarian2_modified_tidy_data <- read.csv("hungarian2_tidydata_modified.csv")

# --------------------------------------------------
# 2. Remove Control questions
# --------------------------------------------------
english_experimental_data <- english_modified_tidy_data %>% 
  filter(!grepl("^Control", question))
hungarian_experimental_data <- hungarian_modified_tidy_data %>% 
  filter(!grepl("^Control", question))
hungarian2_experimental_data <- hungarian2_modified_tidy_data %>% 
  filter(!grepl("^Control", question))

# --------------------------------------------------
# 3. Separate question components + create group labels
# --------------------------------------------------
clean_data <- function(df) {
  df %>%
    separate(question,
             into = c("not", "conj", "animals", "stress_number"),
             sep = "_", fill = "right") %>%
    mutate(not_conjunction = paste(not, conj, sep = "_")) %>%
    select(-not, -conj) %>%
    mutate(group_combined = case_when(
      not_conjunction == "not_or"  & stress_number %in% c("001", "002", "003") ~ "NOT_or",
      not_conjunction == "not_or"  & stress_number %in% c("101", "102", "103") ~ "not_OR",
      not_conjunction == "not_and" & stress_number %in% c("001", "002", "003") ~ "NOT_and",
      not_conjunction == "not_and" & stress_number %in% c("101", "102", "103") ~ "not_AND",
      TRUE ~ not_conjunction
    ))
}

english_experimental_data  <- clean_data(english_experimental_data)
hungarian_experimental_data <- clean_data(hungarian_experimental_data)
hungarian2_experimental_data <- clean_data(hungarian2_experimental_data)

# --------------------------------------------------
# 4. Recode responses â†’ NOR / NAND / Other
# --------------------------------------------------
recode_responses <- function(df) {
  df %>%
    mutate(response_simple = case_when(
      response == "animal 1, animal 2, no animal" ~ "NAND",
      response == "no animal" ~ "NOR",
      TRUE ~ "Other"
    ))
}

english_experimental_data  <- recode_responses(english_experimental_data)
hungarian_experimental_data <- recode_responses(hungarian_experimental_data)
hungarian2_experimental_data <- recode_responses(hungarian2_experimental_data)

# --------------------------------------------------
# 5. Summaries
# --------------------------------------------------
summarize_data <- function(df) {
  df %>%
    group_by(group_combined, response_simple) %>%
    summarise(count = n()) %>%
    mutate(proportion = count / sum(count))
}

english_summary  <- summarize_data(english_experimental_data)
hungarian_summary <- summarize_data(hungarian_experimental_data)
hungarian2_summary <- summarize_data(hungarian2_experimental_data)

# --------------------------------------------------
# 6. Colors for the three categories
# --------------------------------------------------
simple_colors <- c(
  "NOR"  = "#FFD200",  # gold
  "NAND" = "#002855",  # dark blue
  "Other" = "#808080"  # grey
)

# --------------------------------------------------
# 7. Plot function
# --------------------------------------------------
plot_simple <- function(df) {
  ggplot(df, aes(x = group_combined, y = proportion,
                 fill = response_simple)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = simple_colors) +
    labs(x = "Question Group",
         y = "Proportion of Responses",
         fill = "Response Type") +
    theme_bw(base_size = 14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}

# --------------------------------------------------
# 8. Create the three plots
# --------------------------------------------------
plot_simple(english_summary)
plot_simple(hungarian_summary)
plot_simple(hungarian2_summary)


english_summary  <- english_summary  %>% mutate(language = "English\nExperiment 1")
hungarian_summary <- hungarian_summary %>% mutate(language = "Hungarian 1\nExperinemt 2")
hungarian2_summary <- hungarian2_summary %>% mutate(language = "Hungarian 2\nExperiment 3")
all_summary <- bind_rows(english_summary, hungarian_summary, hungarian2_summary)
ggplot(all_summary, aes(x = group_combined,
                        y = proportion,
                        fill = response_simple)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ language, nrow = 1) +   # <<--- top labels
  scale_fill_manual(values = simple_colors) +
  labs(x = "Question Group",
       y = "Proportion",
       fill = "Response Type") +
  theme_bw(base_size = 14) +
  theme(
    strip.text = element_text(size = 14, face = "bold"),  # top label style
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```


```{r}
# Single group pie
ggplot(hungarian2_data_summary, aes(x = response, y = proportion, fill = response)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(proportion, 2)), 
            hjust = -0.1,  # shift text slightly outside the bar
            size = 3.5) +
  facet_wrap(~ group_combined) +
  coord_flip() +
  scale_fill_manual(values = custom_colors) +
  labs(x = "Response", y = "Proportion") +
  theme_minimal() +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold")
  ) +
  expand_limits(y = 1.05)  # ensure space for the labels




```


```{r}
#creating the plot for the control data

#filter control data from the modified tidy data
english_control_data <- english_modified_tidy_data %>%
    filter(grepl("^Control", question))

english_control_data <- english_control_data %>%
  separate(question, into = c("control", "name", "number"), 
           sep = "_", fill = "right")
hungarian_control_data <- hungarian_modified_tidy_data %>%
    filter(grepl("^Control", question))

hungarian_control_data <- hungarian_control_data %>%
  separate(question, into = c("control", "name", "number"), 
           sep = "_", fill = "right")
hungarian2_control_data <- hungarian2_modified_tidy_data %>%
    filter(grepl("^Control", question))

hungarian2_control_data <- hungarian2_control_data %>%
  separate(question, into = c("control", "name", "number"), 
           sep = "_", fill = "right")

#Create the stacked bar plot for the control data
english_control_plot <- english_control_data %>%
    group_by(name, response) %>%
    summarize(count = n(), .groups = "drop") %>%
    mutate(proportion = count / sum(count)) %>%
    ggplot(aes(x = name, y = proportion, fill = as.factor(response))) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Control Questions",
         x = "Question",
         y = "Proportion of Responses",
         fill = "Response") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
hungarian_control_plot <- hungarian_control_data %>%
    group_by(name, response) %>%
    summarize(count = n(), .groups = "drop") %>%
    mutate(proportion = count / sum(count)) %>%
    ggplot(aes(x = name, y = proportion, fill = as.factor(response))) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Control Questions",
         x = "Question",
         y = "Proportion of Responses",
         fill = "Response") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
hungarian2_control_plot <- hungarian2_control_data %>%
    group_by(name, response) %>%
    summarize(count = n(), .groups = "drop") %>%
    mutate(proportion = count / sum(count)) %>%
    ggplot(aes(x = name, y = proportion, fill = as.factor(response))) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "Control Questions",
         x = "Question",
         y = "Proportion of Responses",
         fill = "Response") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(english_control_plot)
print(hungarian2_control_plot)
print(hungarian_control_plot)
```
```{r}


# Read the data
english_df <- read.csv("english_experimental_data.csv")
hungarian_df <- read.csv("hungarian_experimental_data.csv")
hungarian2_df <- read.csv("hungarian2_experimental_data.csv")

# Convert response to factor (required for categorical family)
english_df$response <- as.factor(english_df$response)

english_fit <- brm(
  formula = response ~ group_combined,
  family = categorical(),
  data = english_df
)
# Read the data


# Convert response to factor (required for categorical family)
hungarian_df$response <- as.factor(hungarian_df$response)

hungarian_fit <- brm(
  formula = response ~ group_combined,
  family = categorical(),
  data = hungarian_df
)
# Read the data


# Convert response to factor (required for categorical family)
hungarian2_df$response <- as.factor(hungarian2_df$response)

hungarian2_fit <- brm(
  formula = response ~ group_combined,
  family = categorical(),
  data = hungarian2_df
)


```

```{r}
  # Posterior predictive check
ce <- conditional_effects(english_fit, categorical = TRUE)
plot(ce, plot = TRUE)

# Posterior predictive check
ce <- conditional_effects(hungarian_fit, categorical = TRUE)
plot(ce, plot = TRUE)

# Posterior predictive check
ce <- conditional_effects(hungarian2_fit, categorical = TRUE)
plot(ce, plot = TRUE)

```
#should we include "animal 1, animal 2" and 'animal 1, animal 2, no animal" into joint denial? 
#I want to formalize the response types for easy comparison and similar coloring, but I am not sure whether to put "animal 1, animal 2" into other, or joint denial. 



```{r}
english_fit
hungarian_fit
hungarian2_fit
```

# Casey's Proposed Stats
## Key Question: Do we see more NAND responses to not_AND items across all three experiments?

### Proposed Solution: Three mixed effects logistic regression models on just the "and" trials.

### Caveat: Depending on the data pattern, it may be necessary to separate varying and non-varying subjects due to quasi-separation. An alternate option would be more restrictive priors over by-subject random effects. The code block below plots individual variation in order to assess which if any fixes are needed.
```{r}
e1 = english_experimental_data
e2 = hungarian_experimental_data
e3 = hungarian2_experimental_data

# Labels responses "NAND" and "NOR"
e1$response[e1$response == "animal 1, animal 2, no animal"] = "NAND"
e1$response[e1$response == "no animal"] = "NOR"

e2$response[e2$response == "animal 1, animal 2, no animal"] = "NAND"
e2$response[e2$response == "no animal"] = "NOR"

e3$response[e3$response == "animal 1, animal 2, no animal"] = "NAND"
e3$response[e3$response == "no animal"] = "NOR"

# Remove "or" trials since we aren't analyzing them here
e1 = e1 %>% filter(e1$not_conjunction == "not_and")
e2 = e2 %>% filter(e2$not_conjunction == "not_and")
e3 = e3 %>% filter(e3$not_conjunction == "not_and")

# Excludes "Other" Responses since they are not reasonable interpretations of the stimuli
## This excludes 19/300 trials for E1
e1 = e1 %>% filter(e1$response == "NAND" | e1$response == "NOR")
## This excludes 6/300 trials for E2
e2 = e2 %>% filter(e2$response == "NAND" | e2$response == "NOR")
## This excludes 15/300 trials for E3
e3 = e3 %>% filter(e3$response == "NAND" | e3$response == "NOR")


# Change scores to binary, summarize means
e1$response = ifelse(e1$response == 'NAND', 1, 0)
e1_means = e1 %>% 
  group_by(group_combined) %>% 
  summarise(Mean = mean(response))

## There is a problematic amount of non-varying subjects in E1
e1_individual_means = e1 %>% 
  group_by(ResponseId) %>% 
  summarise(Mean = mean(response))

e2$response = ifelse(e2$response == 'NAND', 1, 0)
e2_means = e2 %>% 
  group_by(group_combined) %>% 
  summarise(Mean = mean(response))

## There is a problematic amount of non-varying subjects in E2
e2_individual_means = e2 %>% 
  group_by(ResponseId) %>% 
  summarise(Mean = mean(response))

e3$response = ifelse(e3$response == 'NAND', 1, 0)
e3_means = e3 %>% 
  group_by(group_combined) %>% 
  summarise(Mean = mean(response))

## There is a problematic amount of non-varying subjects in E3
e3_individual_means = e3 %>% 
  group_by(ResponseId) %>% 
  summarise(Mean = mean(response))

#Summarize degree of non-variance in each study
## 33/50 do not vary
table(e1_individual_means$Mean)
## 32/50 do not vary
table(e2_individual_means$Mean)
## 25/50 do not vary
table(e3_individual_means$Mean)

```

# Experiment 2 BRM
## Step 1: Test for intercept drift
## Step 2: Address if needed (Exclude non varying subjects?)
## Step 3: Run a full model
### Results: NOT_and items resulted in NAND interpretations less often than not_AND trials 95% CI[-9.46, -3.27]
```{r}
# These two models display relatively large intercept drift ~.42 to ~.27. This is indicative of quasi separation, since the true mean NAND is .42
Model_intercept = brm(response ~ 1,
            family = bernoulli,
            data = e2,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(Model_intercept)

Model_random_intercept = brm(response ~ 1 + (1|ResponseId),
            family = bernoulli,
            data = e2,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(Model_random_intercept)

# Create list of subjects whose responses vary (n = 17), and sort the data to just the data from those subjects
e1_varying = filter(e1_individual_means, e1_individual_means$Mean != 0 & e1_individual_means$Mean != 1)
e1varying_data = filter(e1, ResponseId %in% e1_varying$ResponseId)
nrow(table(e1varying_data$ResponseId))

varying_model_e2 = brm(response ~ group_combined + (group_combined|ResponseId),
            family = bernoulli,
            data = e1varying_data,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(varying_model_e1)
plot(varying_model_e1)

```


# Experiment 2 BRM
## Step 1: Test for intercept drift
## Step 2: Address if needed (Exclude non varying subjects?)
## Step 3: Run a full model
### Results: NOT_and items did not result in NAND interpretations less often than not_AND trials 95% CI[-2.98, .92]
```{r}
# These two models display relatively large intercept drift ~.52 to ~.38. This is indicative of quasi separation, since the true mean NAND is .47
Model_intercept = brm(response ~ 1,
            family = bernoulli,
            data = e1,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(Model_intercept)

Model_random_intercept = brm(response ~ 1 + (1|ResponseId),
            family = bernoulli,
            data = e1,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(Model_random_intercept)


# Create list of subjects whose responses vary (n = 18), and sort the data to just the data from those subjects
e2_varying = filter(e2_individual_means, e2_individual_means$Mean != 0 & e2_individual_means$Mean != 1)
e2varying_data = filter(e2, ResponseId %in% e2_varying$ResponseId)
nrow(table(e2varying_data$ResponseId))

varying_model_e2 = brm(response ~ group_combined + (group_combined|ResponseId),
            family = bernoulli,
            data = e2varying_data,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(varying_model_e2)
plot(varying_model_e2)

```

# Experiment 3 BRM
## Step 1: Test for intercept drift
## Step 2: Address if needed (Exclude non varying subjects?)
## Step 3: Run a full model
### Results: NOT_and items resulted in NAND interpretations less often than not_AND trials 95% CI[-7.31, -2.84]
```{r}
# These two models do not display large intercept drift ~.55 to ~.58. This is not necessarily indicative of quasi separation, but for consistency with earlier modeling and because the data itself is still highly categorical for many subjects, I have done the same exclusion procedure.
Model_intercept = brm(response ~ 1,
            family = bernoulli,
            data = e3,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(Model_intercept)

Model_random_intercept = brm(response ~ 1 + (1|ResponseId),
            family = bernoulli,
            data = e3,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(Model_random_intercept)


# Create list of subjects whose responses vary (n = 18), and sort the data to just the data from those subjects
e3_varying = filter(e3_individual_means, e3_individual_means$Mean != 0 & e3_individual_means$Mean != 1)
e3varying_data = filter(e3, ResponseId %in% e3_varying$ResponseId)
nrow(table(e3varying_data$ResponseId))

varying_model_e3 = brm(response ~ group_combined + (group_combined|ResponseId),
            family = bernoulli,
            data = e3varying_data,
            warmup = 1000,
            iter = 4000,
            chains = 4,
            cores = 4,
            #control = list(adapt_delta = 0.95, max_treedepth = 10)
            seed = 4)
summary(varying_model_e3)
plot(varying_model_e3)

```
